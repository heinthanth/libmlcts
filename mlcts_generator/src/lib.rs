//! # mlcts_generator
//!
//! This crate provides function to generate MLCTS text from Myanmar text.
//! Moreover, this also provides utilities functions such as syllable breaker,
//! etc.

use fancy_regex::Regex;
use mlcts_core::*;

/// Convert Myanmar text to MLCTS text.
/// This function internally uses [`split_syllables`] and [`get_token`].
/// So, splitting semantics are the same as [`split_syllables`].
///
/// # Examples
///
/// ```
/// use mlcts_generator::mlcts_from_myanmar;
///
/// let input = "မင်္ဂလာပါ";
/// let mlcts = mlcts_from_myanmar(input);
///
/// assert_eq!(mlcts, "mangga. la pa");
///
/// let input = "你好，赵露思。我姓 <<မောင်မောင်>>。很高兴认识你！";
/// let mlcts = mlcts_from_myanmar(input);
///
/// assert_eq!(mlcts, "你 好 ， 赵 露 思 。 我 姓   <<မောင်မောင်>> 。 很 高 兴 认 识 你 ！");
///
/// let input = "မင်္ဂလာပါ <<赵露思>>။";
/// let mlcts = mlcts_from_myanmar(input);
///
/// assert_eq!(mlcts, "mangga. la pa   <<赵露思>> .");
/// ```
///
/// # Arguments
///
/// * `input` - The Myanmar text to convert.
///
/// # Returns
///
/// Space-separated syllables in MLCTS.
pub fn mlcts_from_myanmar<'i>(input: &'i str) -> String
{
  get_token(input)
    .map(|t| t.to_mlcts(input))
    .collect::<Vec<_>>()
    .join(" ")
}

/// Represents the kind of a token generated by the Myanmar script
/// tokenizer/parser. Token kind can be a syllable or other types of tokens.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TokenKind
{
  /// A syllable token.
  Syllable(Syllable),
  /// Special mapped string
  SpecialMapped(&'static str),
  /// An other token.
  Other,
}

/// Represents a token generated by the Myanmar script tokenizer/parser.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Token
{
  /// The kind of the token.
  pub kind: TokenKind,
  /// The start position of the token in the input.
  pub start: usize,
  /// The length of the token in the input.
  pub len: usize,
}

impl Token
{
  /// Creates a new token with the given kind, start position, and length.
  ///
  /// # Arguments
  ///
  /// * `kind` - The kind of the token.
  /// * `start` - The start position of the token in the input.
  /// * `len` - The length of the token in the input.
  ///
  /// # Returns
  ///
  /// A new token with the given kind, start position, and length.
  pub fn new(kind: TokenKind, start: usize, len: usize) -> Self
  {
    Self { kind, start, len }
  }

  /// Convert Token to MLCTS string
  ///
  /// # Returns
  ///
  /// The MLCTS string.
  pub fn to_mlcts(&self, input: &str) -> String
  {
    match &self.kind
    {
      TokenKind::Syllable(s) => s.to_mlcts(),
      TokenKind::SpecialMapped(s) => s.to_string(),
      _ => input[self.start .. self.start + self.len].to_string(),
    }
  }
}

const EOF_CHAR: char = '\0';

/// Split the input into syllables.
/// This function internally uses [`split_syllables`].
/// So, splitting semantics are the same as [`split_syllables`].
///
/// # Arguments
///
/// * `input` - The input to split.
///
/// # Returns
///
/// The token iterator.
pub fn get_token(input: &str) -> impl Iterator<Item = Token> + use<'_>
{
  split_syllables(input)
    .into_iter()
    .map(|(input, start, len)| {
      let r = match input
      {
        "။" =>
        {
          return Token::new(TokenKind::SpecialMapped("."), start, len);
        }
        "၊" =>
        {
          return Token::new(TokenKind::SpecialMapped(","), start, len);
        }
        _ => parse_syllable(input),
      };

      if r.is_err()
      {
        return Token::new(TokenKind::Other, start, len);
      }

      let syl = r.unwrap();
      return Token::new(
        TokenKind::Syllable(syl.syllable),
        start,
        syl.consumed_len,
      );
    })
}

/// Parse the consonant from the input.
///
/// # Arguments
///
/// * `input` - The input to parse.
///
/// # Returns
///
/// The parsed consonant and the length of bytes used by the consonant.
fn parse_consonant(input: &str) -> Result<(Consonant, usize), &str>
{
  let mut cursor = input.chars();
  let current = cursor.next().unwrap_or_else(|| EOF_CHAR);

  let consonant = BasicConsonant::from_myanmar_alphabet(current);
  if consonant.is_err()
  {
    return Err(input);
  }

  let consonant = consonant.unwrap();
  let consonant = if consonant == BasicConsonant::A
  {
    consonant!(A)
  }
  else
  {
    let medial_pos_1 = cursor.clone().next().unwrap_or_else(|| EOF_CHAR);
    let medial_pos_2 = cursor.clone().nth(1).unwrap_or_else(|| EOF_CHAR);
    let medial_pos_3 = cursor.clone().nth(2).unwrap_or_else(|| EOF_CHAR);

    const MEDIAL_Y: char = 'ျ';
    const MEDIAL_R: char = 'ြ';
    const MEDIAL_W: char = 'ွ';
    const MEDIAL_H: char = 'ှ';

    match (medial_pos_1, medial_pos_2, medial_pos_3)
    {
      // r+w+h
      (MEDIAL_R, MEDIAL_W, MEDIAL_H) =>
      {
        cursor.next();
        cursor.next();
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::Hrw)
      }
      // y+w+h
      (MEDIAL_Y, MEDIAL_W, MEDIAL_H) =>
      {
        cursor.next();
        cursor.next();
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::Hyw)
      }
      // w+h
      (MEDIAL_W, MEDIAL_H, _) =>
      {
        cursor.next();
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::Hw)
      }
      // r+w
      (MEDIAL_R, MEDIAL_W, _) =>
      {
        cursor.next();
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::Rw)
      }
      // y+w
      (MEDIAL_Y, MEDIAL_W, _) =>
      {
        cursor.next();
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::Yw)
      }
      // r+h
      (MEDIAL_R, MEDIAL_H, _) =>
      {
        cursor.next();
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::Hr)
      }
      // y+h
      (MEDIAL_Y, MEDIAL_H, _) =>
      {
        cursor.next();
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::Hy)
      }
      // w
      (MEDIAL_W, ..) =>
      {
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::W)
      }
      // r
      (MEDIAL_R, ..) =>
      {
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::R)
      }
      // y
      (MEDIAL_Y, ..) =>
      {
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::Y)
      }
      // h
      (MEDIAL_H, ..) =>
      {
        cursor.next();
        Consonant::with_medial(consonant, MedialDiacritic::H)
      }
      // no medial diacritic
      _ => Consonant::simple(consonant),
    }
  };

  let consumed_len = input.len() - cursor.as_str().len();
  Ok((consonant, consumed_len))
}

#[derive(Debug)]
enum ParseSpecialStartCharResult
{
  Syllable(Syllable),
  Vowel(Vowel),
  Consonant(Consonant),
}

fn parse_special_start_char(
  input: &str,
) -> Result<(ParseSpecialStartCharResult, usize), &str>
{
  let mut cursor = input.chars();
  let first_char = cursor.next().unwrap_or_else(|| EOF_CHAR);

  // special characters which are not regular consonants
  match first_char
  {
    '၌' =>
    {
      // historic spelling နှိုက်
      // unique combination = 'h' + 'n' + 'ai' + '.'
      let s = syllable!(consonant!(N, H), vowel!(Ai; Creaky));
      Ok((
        ParseSpecialStartCharResult::Syllable(s),
        input.len() - cursor.as_str().len(),
      ))
    }
    '၍' =>
    {
      // historic spelling ရုယ္အ်
      // unique combination = 'r' + 'u' + 'y' + 'a' + 'a'
      let s = syllable!(
        consonant!(R),
        vowel!(U),
        syllable!(consonant!(Y), vowel!(A, A))
      );
      Ok((
        ParseSpecialStartCharResult::Syllable(s),
        input.len() - cursor.as_str().len(),
      ))
    }
    '၏' =>
    {
      // historic spelling ဧအ်
      // unique combination = 'e'
      let s = Syllable::simple(vowel!(E));
      Ok((
        ParseSpecialStartCharResult::Syllable(s),
        input.len() - cursor.as_str().len(),
      ))
    }
    '၎' =>
    {
      let ng = cursor.next().unwrap_or_else(|| EOF_CHAR);
      let asat = cursor.next().unwrap_or_else(|| EOF_CHAR);
      let colon = cursor.next().unwrap_or_else(|| EOF_CHAR);

      if matches!((ng, asat, colon), ('င', '်', 'း'))
      {
        // full ၎င်း
        // should be lany: kaung:
        let s = syllable!(
          consonant!(L),
          vowel!(A, Ny; High),
          syllable!(consonant!(K), vowel!(Au, Ng; High))
        );
        Ok((
          ParseSpecialStartCharResult::Syllable(s),
          input.len() - cursor.as_str().len(),
        ))
      }
      else
      {
        Err(input)
      }
    }
    'ဣ' =>
    {
      let v = ParseSpecialStartCharResult::Vowel(vowel!(I; Creaky));
      Ok((v, input.len() - cursor.as_str().len()))
    }
    'ဤ' =>
    {
      let s = Syllable::simple(vowel!(I));
      Ok((
        ParseSpecialStartCharResult::Syllable(s),
        input.len() - cursor.as_str().len(),
      ))
    }
    'ဥ' =>
    {
      let v = ParseSpecialStartCharResult::Vowel(vowel!(U; Creaky));
      Ok((v, input.len() - cursor.as_str().len()))
    }
    'ဦ' =>
    {
      let v = ParseSpecialStartCharResult::Vowel(vowel!(U));
      Ok((v, input.len() - cursor.as_str().len()))
    }
    'ဧ' =>
    {
      let s = Syllable::simple(vowel!(Ei; High));
      Ok((
        ParseSpecialStartCharResult::Syllable(s),
        input.len() - cursor.as_str().len(),
      ))
    }
    'ဩ' =>
    {
      let s = Syllable::simple(vowel!(Au; High));
      Ok((
        ParseSpecialStartCharResult::Syllable(s),
        input.len() - cursor.as_str().len(),
      ))
    }
    'ဪ' =>
    {
      let s = Syllable::simple(vowel!(Au));
      Ok((
        ParseSpecialStartCharResult::Syllable(s),
        input.len() - cursor.as_str().len(),
      ))
    }
    '။' => Err("."),
    '၊' => Err(","),
    _ => parse_consonant(input)
      .map(|(c, l)| (ParseSpecialStartCharResult::Consonant(c), l)),
  }
}

#[derive(Debug)]
struct ParseSyllableResult
{
  syllable: Syllable,
  consumed_len: usize,
}

macro_rules! parse_syl_result {
  ($syllable:expr, $consumed_len:expr) => {
    Ok(ParseSyllableResult {
      syllable: $syllable,
      consumed_len: $consumed_len,
    })
  };
}

/// Parse the syllable from the input.
///
/// # Arguments
///
/// * `syllable` - Possible syllable input
///
/// # Returns
///
/// The parsed syllable and the length of bytes used by the syllable.
fn parse_syllable<'i>(syllable: &'i str)
  -> Result<ParseSyllableResult, &'i str>
{
  let (first, consumed_bytes_by_first) = parse_special_start_char(syllable)?;

  if let ParseSpecialStartCharResult::Syllable(s) = first
  {
    return parse_syl_result!(s, consumed_bytes_by_first);
  }

  // skip the consumed bytes
  let input_len_left = syllable.len();
  let mut cursor = syllable[consumed_bytes_by_first ..].chars();

  // if the consumed length is equal to the syllable length,
  if cursor.as_str().is_empty()
  {
    match first
    {
      ParseSpecialStartCharResult::Vowel(v) =>
      {
        return parse_syl_result!(
          syllable!(consonant!(A), v),
          input_len_left - cursor.as_str().len()
        );
      }
      ParseSpecialStartCharResult::Consonant(c) =>
      {
        return parse_syl_result!(
          syllable!(c, vowel!(A; Creaky)),
          input_len_left - cursor.as_str().len()
        );
      }
      _ => unreachable!(),
    }
  }

  const ASAT: char = '်';
  const STACK_SIGN: char = '္';

  let (consonant, mut vowel) = match first
  {
    ParseSpecialStartCharResult::Vowel(v) => (consonant!(A), v),
    ParseSpecialStartCharResult::Consonant(consonant) =>
    {
      let v_pos_1 = cursor.clone().next().unwrap_or_else(|| EOF_CHAR);
      let v_pos_2 = cursor.clone().nth(1).unwrap_or_else(|| EOF_CHAR);
      let v_pos_3 = cursor.clone().nth(2).unwrap_or_else(|| EOF_CHAR);

      const VOW_E: char = 'ေ';
      const VOW_A: char = 'ာ';
      const VOW_A_ALT: char = 'ါ';
      const VOW_AI_H: char = 'ဲ';
      const TONE_CREAKY: char = '့';
      const TONE_HIGH: char = 'း';
      const VOW_I: char = 'ီ';
      const VOW_I_CREAKY: char = 'ိ';
      const VOW_U_CREAKY: char = 'ု';
      const VOW_U: char = 'ူ';
      const VOW_M: char = 'ံ';

      let used_vowel = match (v_pos_1, v_pos_2, v_pos_3)
      {
        // e.g. ား
        (VOW_A | VOW_A_ALT, TONE_HIGH, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(A; High)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ာ EOF
        (VOW_A | VOW_A_ALT, EOF_CHAR, EOF_CHAR) =>
        {
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(A)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ာ
        (VOW_A | VOW_A_ALT, ..) =>
        {
          cursor.next();
          vowel!(A)
        }
        // e.g. ံ
        (VOW_M, EOF_CHAR, EOF_CHAR) =>
        {
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(A, M)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ယ်
        ('ယ', ASAT, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Ai)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ဲ့
        (VOW_AI_H, TONE_CREAKY, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Ai; Creaky)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ဲ
        (VOW_AI_H, EOF_CHAR, EOF_CHAR) =>
        {
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Ai; High)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ော်
        (VOW_E, VOW_A | VOW_A_ALT, ASAT) =>
        {
          cursor.next();
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Au)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ော့
        (VOW_E, VOW_A | VOW_A_ALT, TONE_CREAKY) =>
        {
          cursor.next();
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Au; Creaky)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ော EOF
        (VOW_E, VOW_A | VOW_A_ALT, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Au; High)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ော
        (VOW_E, VOW_A | VOW_A_ALT, ..) =>
        {
          cursor.next();
          cursor.next();
          vowel!(Au) // need to check
                     // virama and
                     // stacked
                     // consonant
        }
        // e.g. ူ
        (VOW_U, EOF_CHAR, EOF_CHAR) =>
        {
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(U)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ူး
        (VOW_U, TONE_HIGH, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(U; High)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ု EOF
        (VOW_U_CREAKY, EOF_CHAR, EOF_CHAR) =>
        {
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(U; Creaky)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ုံး
        (VOW_U_CREAKY, VOW_M, TONE_HIGH) =>
        {
          cursor.next();
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Au, M; High)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ုံ့
        (VOW_U_CREAKY, VOW_M, TONE_CREAKY) =>
        {
          cursor.next();
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Au, M; Creaky)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ုံ EOF
        (VOW_U_CREAKY, VOW_M, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Au, M)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ု
        (VOW_U_CREAKY, ..) =>
        {
          cursor.next();
          // need to check virama and stacked consonant
          vowel!(U)
        }
        // e.g. ိုး
        (VOW_I_CREAKY, VOW_U_CREAKY, TONE_HIGH) =>
        {
          cursor.next();
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Ui; High)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ို့
        (VOW_I_CREAKY, VOW_U_CREAKY, TONE_CREAKY) =>
        {
          cursor.next();
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Ui; Creaky)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ို EOF
        (VOW_I_CREAKY, VOW_U_CREAKY, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(Ui)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ို
        (VOW_I_CREAKY, VOW_U_CREAKY, ..) =>
        {
          cursor.next();
          cursor.next();
          vowel!(Ui) // need to check
                     // virama and
                     // stacked
                     // consonant
        }
        // e.g. ီ
        (VOW_I, EOF_CHAR, EOF_CHAR) =>
        {
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(I)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ီး
        (VOW_I, TONE_HIGH, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(I; High)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ိ EOF
        (VOW_I_CREAKY, EOF_CHAR, EOF_CHAR) =>
        {
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(I; Creaky)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ိ
        (VOW_I_CREAKY, ..) =>
        {
          cursor.next();
          vowel!(I) // need to check
                    // virama and
                    // stacked
                    // consonant
        }
        // e.g. ေး
        (VOW_E, TONE_HIGH, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(E; High)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ေ့
        (VOW_E, TONE_CREAKY, EOF_CHAR) =>
        {
          cursor.next();
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(E; Creaky)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ေ EOF
        (VOW_E, EOF_CHAR, EOF_CHAR) =>
        {
          cursor.next();
          return parse_syl_result!(
            syllable!(consonant, vowel!(E)),
            input_len_left - cursor.as_str().len()
          );
        }
        // e.g. ေ
        (VOW_E, ..) =>
        {
          cursor.next();
          vowel!(E) // need to check
                    // virama and
                    // stacked
                    // consonant
        }
        // the rest
        // need to check virama and stacked consonant
        _ => vowel!(A),
      };

      (consonant, used_vowel)
    }
    ParseSpecialStartCharResult::Syllable(_) => unreachable!(),
  };

  // almost all possible ending of a syllable
  // is already handled above, so it's safe to assume
  // that next character is a consonant.
  let top_consonant = cursor.next().unwrap_or_else(|| EOF_CHAR);
  let sign = cursor.clone().next().unwrap_or_else(|| EOF_CHAR);
  let virama_sign_or_bottom_consonant =
    cursor.clone().nth(1).unwrap_or_else(|| EOF_CHAR);
  let extra_char = cursor.clone().nth(2).unwrap_or_else(|| EOF_CHAR);

  match (
    top_consonant,
    sign,
    virama_sign_or_bottom_consonant,
    extra_char,
  )
  {
    ('က', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::K);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('က', STACK_SIGN, 'က' | 'ခ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::K);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(r) => r,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ဂ', STACK_SIGN, 'ဂ' | 'ဃ', ..) =>
    {
      vowel.virama = Some(Virama::G);
      cursor.next();
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('င', ASAT, STACK_SIGN, EOF_CHAR) =>
    {
      // this is invalid
      return Err(syllable);
    }
    ('င', ASAT, STACK_SIGN, ..) =>
    {
      vowel.virama = Some(Virama::Ng);
      cursor.next();
      cursor.next();

      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('င', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::Ng);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('င', ASAT, 'း', EOF_CHAR) =>
    {
      cursor.next();
      cursor.next();
      vowel.virama = Some(Virama::Ng);
      vowel.tone = Some(Tone::High);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('င', ASAT, '့', EOF_CHAR) =>
    {
      cursor.next();
      cursor.next();
      vowel.virama = Some(Virama::Ng);
      vowel.tone = Some(Tone::Creaky);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('စ', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::C);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('စ', STACK_SIGN, 'စ' | 'ဆ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::C);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ဇ', STACK_SIGN, 'ဇ' | 'ဈ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::J);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ည' | 'ဉ', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::Ny);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('ည' | 'ဉ', ASAT, '့', EOF_CHAR) =>
    {
      cursor.next();
      cursor.next();
      vowel.virama = Some(Virama::Ny);
      vowel.tone = Some(Tone::Creaky);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('ည' | 'ဉ', ASAT, 'း', EOF_CHAR) =>
    {
      cursor.next();
      cursor.next();
      vowel.virama = Some(Virama::Ny);
      vowel.tone = Some(Tone::High);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('ည' | 'ဉ', STACK_SIGN, 'စ' | 'ဇ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::Ny);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ဋ', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::T);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('ဋ', STACK_SIGN, 'ဋ' | 'ဌ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::T);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ဍ', STACK_SIGN, 'ဍ' | 'ဎ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::D);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ဏ', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::N);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('ဏ', STACK_SIGN, 'ဍ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::N);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('တ', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::T);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('တ', STACK_SIGN, 'တ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::T);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ထ', STACK_SIGN, 'ထ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::Ht);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ဒ', STACK_SIGN, 'ဒ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::D);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('န', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::N);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('န', ASAT, 'း', EOF_CHAR) =>
    {
      cursor.next();
      cursor.next();
      vowel.virama = Some(Virama::N);
      vowel.tone = Some(Tone::High);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('န', ASAT, '့', EOF_CHAR) =>
    {
      cursor.next();
      cursor.next();
      vowel.virama = Some(Virama::N);
      vowel.tone = Some(Tone::Creaky);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('န', STACK_SIGN, 'တ' | 'ထ' | 'ဒ' | 'ဓ' | 'န', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::N);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ပ', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::P);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('ပ', STACK_SIGN, 'ပ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::P);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ဗ', STACK_SIGN, 'ဗ' | 'ဘ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::B);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('မ', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::M);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('မ', ASAT, 'း', EOF_CHAR) =>
    {
      cursor.next();
      cursor.next();
      vowel.virama = Some(Virama::M);
      vowel.tone = Some(Tone::High);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('မ', ASAT, '့', EOF_CHAR) =>
    {
      cursor.next();
      cursor.next();
      vowel.virama = Some(Virama::M);
      vowel.tone = Some(Tone::Creaky);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('မ', STACK_SIGN, 'ပ' | 'ဗ' | 'ဘ' | 'မ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::M);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('ဿ', ..) =>
    {
      vowel.virama = Some(Virama::S);
      let new_str = format!("သ{}", cursor.as_str());
      let mut c = match parse_syllable(&new_str)
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      c.consumed_len -= "သ".len();

      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    ('လ', ASAT, EOF_CHAR, EOF_CHAR) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::L);
      return parse_syl_result!(
        syllable!(consonant, vowel),
        input_len_left - cursor.as_str().len()
      );
    }
    ('လ', STACK_SIGN, 'လ', ..) =>
    {
      cursor.next();
      vowel.virama = Some(Virama::L);
      let c = match parse_syllable(cursor.as_str())
      {
        Ok(c) => c,
        Err(_) => return Err(syllable),
      };
      return parse_syl_result!(
        syllable!(consonant, vowel, c.syllable),
        input_len_left - (cursor.as_str().len() - c.consumed_len)
      );
    }
    _ => Err(syllable),
  }
}

/// Splits the input text into syllables.
///
/// # Notes
/// * The bottom consonant in a stacked consonants are not separated from the
///   top consonant. (E.g. တက္ကသိုလ် is split as တက္က သိုလ်)
/// * Any text enclosed in << and >> is considered as a single syllable.
/// * Any other characters apart from Myanmar consonants, vowel related symbols
///   and ဿ are considered as a single syllable. So, it's good to enclose
///  them in << and >>.
///
/// # Example
///
/// ```
/// let input = "ကျွန်တော်က တက္ကသိုလ်ကျောင်းသားပါ။";
/// let syllables = mlcts_generator::split_syllables(input);
/// let expected = vec!["ကျွန်", "တော်", "က", " ", "တက္က", "သိုလ်", "ကျောင်း", "သား", "ပါ", "။"];
/// assert_eq!(syllables.into_iter().map(|s| s.0).collect::<Vec<_>>(), expected);
/// ```
///
/// # Arguments
///
/// * `input` - The input text to split.
///
/// # Returns
///
/// A vector of syllables.
pub fn split_syllables<'i>(input: &'i str) -> Vec<(&'i str, usize, usize)>
{
  // this regex is borrowed from https://github.com/ye-kyaw-thu/myWord.

  // original regex
  // let p = format!(
  //   r"((?<!္)([က-အ])(?![်္])|[a-zA-Z0-9{}])",
  //   "ဣဤဥဦဧဩဪ၌၍၏၎၀-၉၊။!-/:-@\\[-`{-~\\s"
  // );

  // modified regex: basically,
  // 1. any text enclosed in << and >> is considered as a single syllable.
  // 2. any consonant that does not follow a virama and not followed by an asat
  //    or a virama is considered as a single syllable.
  // 3. any other characters apart from myanmar consonant, vowel related symbols
  //    and ဿ are considered as a single syllable.
  let p = format!(
    r"(<<.*?>>)|((?<!္)([က-အ])(?![်္])|{})",
    "[^\u{102b}-\u{1032}\u{1036}-\u{103e}က-အဿ]"
  );

  let matches = Regex::new(&p)
    .unwrap()
    .find_iter(input)
    .filter_map(Result::ok)
    .map(|m| m.start())
    .collect::<Vec<usize>>();

  matches
    .windows(2)
    .map(|w| {
      let start = w[0];
      let len = w[1] - start;
      (input.get(start .. w[1]).unwrap(), start, len)
    })
    .chain(matches.last().map(|&l| {
      let start = l;
      let len = input.len() - start;
      (input.get(start ..).unwrap(), start, len)
    }))
    .collect()
}

#[cfg(test)]
mod tests
{
  #[test]
  fn test_split_syllables()
  {
    let input = "";
    let syllables = super::split_syllables(input);
    assert_eq!(syllables.len(), 0);

    // sample text is also borrowed from https://github.com/ye-kyaw-thu/myWord
    let input = "ကျွန်တော်ကသုတေသနသမားပါ။\n\
    နေ့ရောညရောမြန်မာစာနဲ့ကွန်ပျူတာနဲ့ပဲအလုပ် များ ပါ တယ်\n\
    မင်းကကောဘာအလုပ်လုပ်တာလဲ။\n\
    ပြောပြပါအုံး\n\
    ကော်ဖီလည်းထပ်သောက်ချင်ရင်ပြောကွာ";

    let syllables = super::split_syllables(input);
    #[rustfmt::skip]
    let expected: Vec<&str> = vec![
      "ကျွန်", "တော်", "က", "သု", "တေ", "သ", "န", "သ", "မား", "ပါ", "။", "\n",
      "နေ့", "ရော", "ည", "ရော", "မြန်", "မာ", "စာ", "နဲ့",
      "ကွန်", "ပျူ", "တာ", "နဲ့", "ပဲ",
      "အ", "လုပ်", " ", "များ", " ", "ပါ", " ", "တယ်", "\n",
      "မင်း", "က", "ကော","ဘာ", "အ", "လုပ်", "လုပ်", "တာ", "လဲ", "။", "\n",
      "ပြော", "ပြ", "ပါ", "အုံး", "\n",
      "ကော်", "ဖီ", "လည်း", "ထပ်", "သောက်", "ချင်", "ရင်", "ပြော", "ကွာ"];
    assert_eq!(
      syllables.into_iter().map(|s| s.0).collect::<Vec<_>>(),
      expected
    );

    let input = "ပိဿာ";
    let syllables = super::split_syllables(input);
    assert_eq!(
      syllables.iter().map(|s| s.0).collect::<Vec<_>>(),
      vec!["ပိဿာ"]
    );

    let input = "သန္နိဋ္ဌာန်";
    let syllables = super::split_syllables(input);
    assert_eq!(
      syllables.iter().map(|s| s.0).collect::<Vec<_>>(),
      vec!["သန္နိဋ္ဌာန်"]
    );

    let input = "မင်္ဂလာပါ<< မောင်မောင် >>။";
    let syllables = super::split_syllables(input);
    assert_eq!(
      syllables.iter().map(|s| s.0).collect::<Vec<_>>(),
      vec!["မင်္ဂ", "လာ", "ပါ", "<< မောင်မောင် >>", "။"]
    );

    let input = "မင်္ဂလာပါ赵露思။";
    let syllables = super::split_syllables(input);
    assert_eq!(
      syllables.iter().map(|s| s.0).collect::<Vec<_>>(),
      vec!["မင်္ဂ", "လာ", "ပါ", "赵", "露", "思", "။"]
    );

    let input = "你好，赵露思。我姓 <<မောင်မောင်>>。很高兴认识你！";
    let syllables = super::split_syllables(input);
    #[rustfmt::skip]
    let expected = vec![
      "你", "好", "，", "赵", "露", "思", "。",
      "我", "姓", " ", "<<မောင်မောင်>>", "。",
      "很", "高", "兴", "认", "识", "你", "！"
    ];
    assert_eq!(syllables.iter().map(|s| s.0).collect::<Vec<_>>(), expected);
  }

  #[test]
  fn test_mlcts_generator()
  {
    let input = "";
    let mlcts = super::mlcts_from_myanmar(input);
    assert_eq!(mlcts, "");

    let input = "ပိဿာ";
    let mlcts = super::mlcts_from_myanmar(input);
    assert_eq!(mlcts, "pissa");

    let input = "တက္ကသိုလ်";
    let mlcts = super::mlcts_from_myanmar(input);
    assert_eq!(mlcts, "takka. suil");

    let input = "၍";
    let mlcts = super::mlcts_from_myanmar(input);
    assert_eq!(mlcts, "ruyaa");

    let input = "၎င်း";
    let mlcts = super::mlcts_from_myanmar(input);
    assert_eq!(mlcts, "lany:kaung:");

    let input = "၎င်းသည်";
    let mlcts = super::mlcts_from_myanmar(input);
    assert_eq!(mlcts, "lany:kaung: sany");

    let input = "ကျွန်တော်ကသုတေသနသမားပါ။\n\
    နေ့ရောညရောမြန်မာစာနဲ့ကွန်ပျူတာနဲ့ပဲအလုပ် များ ပါ တယ်။\n\
    မင်းကကောဘာအလုပ်လုပ်တာလဲ။\n\
    ပြောပြပါအုံး\n\
    ကော်ဖီလည်းထပ်သောက်ချင်ရင်ပြောကွာ";
    let mlcts = super::mlcts_from_myanmar(input);
    assert_eq!(mlcts, "kywan tau ka. su. te sa. na. sa. ma: pa . \n \
      ne. rau: nya. rau: mran ma ca nai. kwan pyu ta nai. pai: a. lup   mya:   pa   tai . \n \
      mang: ka. kau: bha a. lup lup ta lai: . \n \
      prau: pra. pa aum: \n \
      kau hpi lany: htap sauk hkyang rang prau: kwa");
  }
}
