use std::str::Chars;

use crate::core::*;

pub(crate) const EOF_CHAR: char = '\0';

/// Represents the kind of a token generated by the tokenizer.
/// Token kind can be a syllable or other types of tokens.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TokenKind
{
  /// An unknown token.
  Unknown,
  /// A whitespace token.
  Whitespace,
  /// A syllable token.
  Syllable(Syllable),
  /// An EOI token.
  EndOfInput,
}

/// Represents a token generated by the tokenizer.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Token
{
  /// The kind of the token.
  pub kind: TokenKind,
  /// The start position of the token in the input.
  pub start: usize,
  /// The length of the token in the input.
  pub len: usize,
}

impl Token
{
  /// Creates a new token with the given kind, start position, and length.
  ///
  /// # Arguments
  ///
  /// * `kind` - The kind of the token.
  /// * `start` - The start position of the token in the input.
  /// * `len` - The length of the token in the input.
  ///
  /// # Returns
  ///
  /// A new token with the given kind, start position, and length.
  pub fn new(kind: TokenKind, start: usize, len: usize) -> Self
  {
    Self { kind, start, len }
  }
}

/// The tokenizer for MLCTS.
/// This will convert the string written in MLCTS to a sequence of syllables or
/// other tokens.
#[derive(Debug, Clone)]
pub struct Tokenizer<'i>
{
  /// The input iterator.
  input: Chars<'i>,
  /// The start position of the input.
  start: usize,
  /// Length remaining in the input.
  len_remaining: usize,
}

/// Check if a character is a valid character used in MLCTS.
/// This can be used to check the boundary or range of text which needs to be
/// further analyzed to see if it is a valid syllable.
///
/// # Arguments
///
/// * `c` - The character to check.
///
/// # Returns
///
/// `true` if the character is a valid character used in MLCTS, `false`
/// otherwise.
fn is_valid_mlcts_char(c: char) -> bool
{
  matches!(
    c,
    'k'
      | 'h'
      | 'g'
      | 'n'
      | 'c'
      | 'j'
      | 't'
      | 'd'
      | 'p'
      | 'b'
      | 'm'
      | 'y'
      | 'r'
      | 'l'
      | 'w'
      | 's'
      | 'a'
      | 'i'
      | 'u'
      | 'e'
      | '.'
      | ':'
  )
}

/// Check if the current character is a whitespace character.
///
/// # Returns
///
/// `true` if the current character is a whitespace character, `false`
/// otherwise.
fn is_whitespace(c: char) -> bool
{
  matches!(
    c,
    // Usual ASCII suspects
    '\u{0009}'   // \t
    | '\u{000A}' // \n
    | '\u{000B}' // vertical tab
    | '\u{000C}' // form feed
    | '\u{000D}' // \r
    | '\u{0020}' // space
    // NEXT LINE from latin1
    | '\u{0085}'
    // Bidi markers
    | '\u{200E}' // LEFT-TO-RIGHT MARK
    | '\u{200F}' // RIGHT-TO-LEFT MARK
    // Dedicated whitespace characters from Unicode
    | '\u{2028}' // LINE SEPARATOR
    | '\u{2029}' // PARAGRAPH SEPARATOR
  )
}

impl<'i> Tokenizer<'i>
{
  /// Creates a new tokenizer with the given input.
  ///
  /// # Arguments
  ///
  /// * `input` - The input string to tokenize.
  ///
  /// # Returns
  ///
  /// A new tokenizer with the given input.
  pub fn new(input: &'i str) -> Self
  {
    Self {
      input: input.chars(),
      start: 0,
      len_remaining: input.len(),
    }
  }

  /// Get the amount of consumed input.
  ///
  /// # Returns
  ///
  /// The amount of consumed input.
  pub fn consumed_len(&self) -> usize
  {
    self.len_remaining - self.input.as_str().len()
  }

  /// Reset the consumed length counter to zero.
  pub fn reset_consumed_len(&mut self)
  {
    self.start += self.consumed_len();
    self.len_remaining = self.input.as_str().len();
  }

  /// Check if the input iterator has reached the end.
  ///
  /// # Returns
  ///
  /// `true` if the input iterator has reached the end, `false` otherwise.
  fn is_eof(&self) -> bool
  {
    self.input.as_str().is_empty()
  }

  /// Get the current character from the input iterator. And
  /// advance the iterator to the next character. This will return
  /// None if the iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The current character from the input iterator.
  fn advance(&mut self) -> Option<char>
  {
    self.input.next()
  }

  /// Peek the current character from the input iterator without
  /// advancing the iterator. This will return `EOF_CHAR` if the
  /// iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The current character from the input iterator.
  fn peek(&self) -> char
  {
    self.input.clone().next().unwrap_or(EOF_CHAR)
  }

  /// Peek the next character from the input iterator without
  /// advancing the iterator. This will return `EOF_CHAR` if the
  /// iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The next character from the input iterator.
  fn peek_next(&self) -> char
  {
    let mut peek = self.input.clone();
    peek.next();
    peek.next().unwrap_or(EOF_CHAR)
  }

  /// Parse a whitespace token.
  /// This will consume all the whitespace characters from the input.
  ///
  /// # Returns
  ///
  /// A whitespace token.
  fn parse_whitespace(&mut self) -> TokenKind
  {
    while is_whitespace(self.peek()) && !self.is_eof()
    {
      self.advance();
    }
    TokenKind::Whitespace
  }

  /// Parse an unknown token.
  /// This will consume the characters until it reaches (a whitespace or a
  /// syllable character).
  ///
  /// # Returns
  ///
  /// An unknown token.
  fn parse_unknown(&mut self) -> TokenKind
  {
    while !is_whitespace(self.peek())
      && !is_valid_mlcts_char(self.peek())
      && !self.is_eof()
    {
      self.advance();
    }
    TokenKind::Unknown
  }

  /// Parse a tone symbol if exists.
  ///
  /// # Returns
  ///
  /// A tone if valid, otherwise `None`.
  fn parse_tone(&mut self) -> Option<Tone>
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        Some(Tone::High)
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        Some(Tone::Creaky)
      }
      _ => None,
    }
  }

  /// Parse the vowel 'i' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_i(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return Vowel::with_tone(BasicVowel::I, Some(Tone::High));
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return Vowel::with_tone(BasicVowel::I, Some(Tone::Creaky));
      }
      't' =>
      {
        // consume 't'
        self.advance();
        // 'it' can't have a tone mark
        return Vowel::with_virama(BasicVowel::I, Virama::T);
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        // 'ip' can't have a tone mark
        return Vowel::with_virama(BasicVowel::I, Virama::P);
      }
      'n' =>
      {
        // consume 'n'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::I, Some(Virama::N), tone);
      }
      'm' =>
      {
        // consume 'm'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::I, Some(Virama::M), tone);
      }
      _ => Vowel::simple(BasicVowel::I),
    }
  }

  /// Parse the vowel 'ui' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_ui(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return Vowel::with_tone(BasicVowel::Ui, Some(Tone::High));
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return Vowel::with_tone(BasicVowel::Ui, Some(Tone::Creaky));
      }
      'k' =>
      {
        // consume 'k'
        self.advance();
        // 'uik' can't have a tone mark
        return Vowel::with_virama(BasicVowel::Ui, Virama::K);
      }
      c if c == 'n' && self.peek_next() == 'g' =>
      {
        // consume 'n' and 'g'
        self.advance();
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::Ui, Some(Virama::Ng), tone);
      }
      _ => Vowel::simple(BasicVowel::Ui),
    }
  }

  /// Parse the vowel 'u' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_u(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return Vowel::with_tone(BasicVowel::U, Some(Tone::High));
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return Vowel::with_tone(BasicVowel::U, Some(Tone::Creaky));
      }
      'i' =>
      {
        // consume 'i'
        self.advance();
        return self.parse_vowel_ui();
      }
      't' =>
      {
        // consume 't'
        self.advance();
        // 'ut' can't have a tone mark
        return Vowel::with_virama(BasicVowel::U, Virama::T);
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        // 'up' can't have a tone mark
        return Vowel::with_virama(BasicVowel::U, Virama::P);
      }
      'n' =>
      {
        // consume 'n'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::U, Some(Virama::N), tone);
      }
      'm' =>
      {
        // consume 'm'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::U, Some(Virama::M), tone);
      }
      _ => Vowel::simple(BasicVowel::U),
    }
  }

  /// Parse the vowel 'e' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_e(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return Vowel::with_tone(BasicVowel::E, Some(Tone::High));
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return Vowel::with_tone(BasicVowel::E, Some(Tone::Creaky));
      }
      _ => Vowel::simple(BasicVowel::E),
    }
  }

  /// Parse the vowel 'au' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_au(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return Vowel::with_tone(BasicVowel::Au, Some(Tone::High));
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return Vowel::with_tone(BasicVowel::Au, Some(Tone::Creaky));
      }
      'k' =>
      {
        // consume 'k'
        self.advance();
        // 'auk' can't have a tone mark
        return Vowel::with_virama(BasicVowel::Au, Virama::K);
      }
      c if c == 'n' && self.peek_next() == 'g' =>
      {
        // consume 'n' and 'g'
        self.advance();
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::Au, Some(Virama::Ng), tone);
      }
      _ => Vowel::simple(BasicVowel::Au),
    }
  }

  /// Parse the vowel 'an' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_an(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return Vowel::new(BasicVowel::A, Some(Virama::N), Some(Tone::High));
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return Vowel::new(BasicVowel::A, Some(Virama::N), Some(Tone::Creaky));
      }
      'g' =>
      {
        // consume 'g'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::A, Some(Virama::Ng), tone);
      }
      'y' =>
      {
        // consume 'y'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::A, Some(Virama::Ny), tone);
      }
      _ => Vowel::with_virama(BasicVowel::A, Virama::N),
    }
  }

  /// Parse the vowel 'a' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_a(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return Vowel::with_tone(BasicVowel::A, Some(Tone::High));
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return Vowel::with_tone(BasicVowel::A, Some(Tone::Creaky));
      }
      'k' =>
      {
        // consume 'k'
        self.advance();
        // 'ak' can't have a tone mark
        return Vowel::with_virama(BasicVowel::A, Virama::K);
      }
      'c' =>
      {
        // consume 'c'
        self.advance();
        // 'ac' can't have a tone mark
        return Vowel::with_virama(BasicVowel::A, Virama::C);
      }
      't' =>
      {
        // consume 't'
        self.advance();
        // 'at' can't have a tone mark
        return Vowel::with_virama(BasicVowel::A, Virama::T);
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        // 'ap' can't have a tone mark
        return Vowel::with_virama(BasicVowel::A, Virama::P);
      }
      'm' =>
      {
        // consume 'm'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::A, Some(Virama::M), tone);
      }
      'u' =>
      {
        // consume 'u'
        self.advance();
        return self.parse_vowel_au();
      }
      'n' =>
      {
        // consume 'n'
        self.advance();
        return self.parse_vowel_an();
      }
      _ => Vowel::simple(BasicVowel::A),
    }
  }

  /// Parse vowel to get the syllable token.
  ///
  /// # Arguments
  ///
  /// * `first_char` - The first vowel character.
  ///
  /// # Returns
  ///
  /// A syllable token if valid, otherwise an unknown token.
  fn parse_vowel(&mut self, first_char: char) -> TokenKind
  {
    TokenKind::Syllable(Syllable::with_vowel(match first_char
    {
      'i' => self.parse_vowel_i(),
      'u' => self.parse_vowel_u(),
      'e' => self.parse_vowel_e(),
      _ => unreachable!(),
    }))
  }

  /// Handle the special case of 'h' which can form a medial consonant.
  ///
  /// # Returns
  ///
  /// A valid consonant part.
  fn parse_consonant_h(&mut self) -> Consonant
  {
    match self.peek()
    {
      'k' =>
      {
        // consume 'k'
        self.advance();
        Consonant::simple(BasicConsonant::Hk)
      }
      'c' =>
      {
        // consume 'c'
        self.advance();
        Consonant::simple(BasicConsonant::Hc)
      }
      't' =>
      {
        // consume 't'
        self.advance();
        Consonant::simple(BasicConsonant::Ht)
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        Consonant::simple(BasicConsonant::Hp)
      }
      'n' => match self.peek()
      {
        'g' =>
        {
          // consume 'n'
          self.advance();
          // consume 'g'
          self.advance();
          Consonant::with_medial(BasicConsonant::Ng, MedialDiacritic::H)
        }
        'y' =>
        {
          // consume 'n'
          self.advance();
          // consume 'y'
          self.advance();
          Consonant::with_medial(BasicConsonant::Ny, MedialDiacritic::H)
        }
        _ =>
        {
          // consume 'n'
          self.advance();
          Consonant::with_medial(BasicConsonant::N, MedialDiacritic::H)
        }
      },
      'm' =>
      {
        // consume 'm'
        self.advance();
        Consonant::with_medial(BasicConsonant::M, MedialDiacritic::H)
      }
      'y' =>
      {
        // consume 'y'
        self.advance();
        Consonant::with_medial(BasicConsonant::Y, MedialDiacritic::H)
      }
      'r' =>
      {
        // consume 'r'
        self.advance();
        Consonant::with_medial(BasicConsonant::R, MedialDiacritic::H)
      }
      'l' =>
      {
        // consume 'l'
        self.advance();
        Consonant::with_medial(BasicConsonant::L, MedialDiacritic::H)
      }
      'w' =>
      {
        // consume 'w'
        self.advance();
        Consonant::with_medial(BasicConsonant::W, MedialDiacritic::H)
      }
      _ => Consonant::simple(BasicConsonant::H),
    }
  }

  /// Parse the consonant and following vowel to get the syllable token.
  ///
  /// # Arguments
  ///
  /// * `first_char` - The first consonant character.
  ///
  /// # Returns
  ///
  /// A syllable token if valid, otherwise an unknown token.
  fn parse_consonant(&mut self, first_char: char) -> TokenKind
  {
    let consonant = match first_char
    {
      'k' => Consonant::simple(BasicConsonant::K),
      'h' => self.parse_consonant_h(),
      'g' => match self.peek()
      {
        'h' =>
        {
          // consume 'y'
          self.advance();
          Consonant::simple(BasicConsonant::Gh)
        }
        _ => Consonant::simple(BasicConsonant::G),
      },
      'n' =>
      {
        match self.peek()
        {
          'g' =>
          {
            // consume 'g'
            self.advance();
            Consonant::simple(BasicConsonant::Ng)
          }
          'y' =>
          {
            // consume 'y'
            self.advance();
            Consonant::simple(BasicConsonant::Ny)
          }
          _ => Consonant::simple(BasicConsonant::N),
        }
      }
      'c' => Consonant::simple(BasicConsonant::C),
      'j' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          Consonant::simple(BasicConsonant::Jh)
        }
        _ => Consonant::simple(BasicConsonant::J),
      },
      't' => Consonant::simple(BasicConsonant::T),
      'd' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          Consonant::simple(BasicConsonant::Dh)
        }
        _ => Consonant::simple(BasicConsonant::D),
      },
      'p' => Consonant::simple(BasicConsonant::P),
      'b' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          Consonant::simple(BasicConsonant::Bh)
        }
        _ => Consonant::simple(BasicConsonant::B),
      },
      'm' => Consonant::simple(BasicConsonant::M),
      'y' => Consonant::simple(BasicConsonant::Y),
      'r' => Consonant::simple(BasicConsonant::R),
      'l' => Consonant::simple(BasicConsonant::L),
      'w' => Consonant::simple(BasicConsonant::W),
      's' => Consonant::simple(BasicConsonant::S),
      'a' => Consonant::simple(BasicConsonant::A),
      _ => unreachable!(),
    };

    // if basic consonant is 'a', then it's a vowel.
    // no need to check for medial consonant and vowel.
    if consonant.basic == BasicConsonant::A
    {
      let vowel = self.parse_vowel_a();
      return TokenKind::Syllable(Syllable::with_vowel(vowel));
    }

    // check for medial consonant 'y' and 'r'
    let consonant = if matches!(
      consonant.basic,
      BasicConsonant::K
        | BasicConsonant::Hk
        | BasicConsonant::G
        | BasicConsonant::Gh
        | BasicConsonant::Ng
        | BasicConsonant::P
        | BasicConsonant::Hp
        | BasicConsonant::B
        | BasicConsonant::M
        | BasicConsonant::L
        | BasicConsonant::S
    ) && self.peek() == 'y'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::Y),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'y'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else if matches!(
      consonant.basic,
      BasicConsonant::K
        | BasicConsonant::Hk
        | BasicConsonant::G
        | BasicConsonant::Gh
        | BasicConsonant::Ng
        | BasicConsonant::P
        | BasicConsonant::Hp
        | BasicConsonant::B
        | BasicConsonant::M
    ) && self.peek() == 'r'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::R),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'r'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else
    {
      consonant
    };

    // since 'w' can be combined with almost all consonants, check for 'w'
    let consonant = if self.peek() == 'w'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::W),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'w'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else
    {
      consonant
    };

    let vowel = match self.peek()
    {
      'a' =>
      {
        // consume 'a'
        self.advance();
        Some(self.parse_vowel_a())
      }
      'i' =>
      {
        // consume 'i'
        self.advance();
        Some(self.parse_vowel_i())
      }
      'u' =>
      {
        // consume 'u'
        self.advance();
        Some(self.parse_vowel_u())
      }
      'e' =>
      {
        // consume 'e'
        self.advance();
        Some(self.parse_vowel_e())
      }
      _ => None,
    };

    if vowel.is_none()
    {
      // since there is no vowel, it's an unknown token.
      return TokenKind::Unknown;
    }

    TokenKind::Syllable(Syllable::new(consonant, vowel.unwrap()))
  }

  /// Get the next possible token from the input.
  /// This will return the next token from the input. If the input
  /// has reached the end, this will return an EOI token.
  ///
  /// # Returns
  ///
  /// The next token from the input.
  pub fn next_token(&mut self) -> Token
  {
    let first_char = match self.advance()
    {
      Some(c) => c,
      None => return Token::new(TokenKind::EndOfInput, 0, 0),
    };

    let token_kind = match first_char
    {
      'k' | 'h' | 'g' | 'n' | 'c' | 'j' | 't' | 'd' | 'p' | 'b' | 'm' | 'y'
      | 'r' | 'l' | 'w' | 's' | 'a' => self.parse_consonant(first_char),
      'i' | 'u' | 'e' => self.parse_vowel(first_char),
      c if is_whitespace(c) => self.parse_whitespace(),
      _ => self.parse_unknown(),
    };

    let token = Token::new(token_kind, self.start, self.consumed_len());
    self.reset_consumed_len();
    token
  }
}
