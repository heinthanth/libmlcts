use std::str::Chars;

use crate::{core::*, syllable};
use crate::{consonant, vowel};

pub(crate) const EOF_CHAR: char = '\0';

/// Represents the kind of a token generated by the tokenizer.
/// Token kind can be a syllable or other types of tokens.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TokenKind
{
  /// An unknown token.
  Unknown,
  /// A whitespace token.
  Whitespace,
  /// A syllable token.
  Syllable(Syllable),
  /// An EOI token.
  EndOfInput,
}

/// Represents a token generated by the tokenizer.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Token
{
  /// The kind of the token.
  pub kind: TokenKind,
  /// The start position of the token in the input.
  pub start: usize,
  /// The length of the token in the input.
  pub len: usize,
}

impl Token
{
  /// Creates a new token with the given kind, start position, and length.
  ///
  /// # Arguments
  ///
  /// * `kind` - The kind of the token.
  /// * `start` - The start position of the token in the input.
  /// * `len` - The length of the token in the input.
  ///
  /// # Returns
  ///
  /// A new token with the given kind, start position, and length.
  pub fn new(kind: TokenKind, start: usize, len: usize) -> Self
  {
    Self { kind, start, len }
  }
}

/// The tokenizer for MLCTS.
/// This will convert the string written in MLCTS to a sequence of syllables or
/// other tokens.
#[derive(Debug, Clone)]
pub struct Tokenizer<'i>
{
  /// The input iterator.
  input: Chars<'i>,
  /// The start position of the input.
  start: usize,
  /// Length remaining in the input.
  len_remaining: usize,
}

/// Check if a character is a valid character used in MLCTS.
/// This can be used to check the boundary or range of text which needs to be
/// further analyzed to see if it is a valid syllable.
///
/// # Arguments
///
/// * `c` - The character to check.
///
/// # Returns
///
/// `true` if the character is a valid character used in MLCTS, `false`
/// otherwise.
fn is_valid_mlcts_char(c: char) -> bool
{
  matches!(
    c,
    'k'
      | 'h'
      | 'g'
      | 'n'
      | 'c'
      | 'j'
      | 't'
      | 'd'
      | 'p'
      | 'b'
      | 'm'
      | 'y'
      | 'r'
      | 'l'
      | 'w'
      | 's'
      | 'a'
      | 'i'
      | 'u'
      | 'e'
      | '.'
      | ':'
  )
}

/// Check if the current character is a whitespace character.
///
/// # Returns
///
/// `true` if the current character is a whitespace character, `false`
/// otherwise.
fn is_whitespace(c: char) -> bool
{
  matches!(
    c,
    // Usual ASCII suspects
    '\u{0009}'   // \t
    | '\u{000A}' // \n
    | '\u{000B}' // vertical tab
    | '\u{000C}' // form feed
    | '\u{000D}' // \r
    | '\u{0020}' // space
    // NEXT LINE from latin1
    | '\u{0085}'
    // Bidi markers
    | '\u{200E}' // LEFT-TO-RIGHT MARK
    | '\u{200F}' // RIGHT-TO-LEFT MARK
    // Dedicated whitespace characters from Unicode
    | '\u{2028}' // LINE SEPARATOR
    | '\u{2029}' // PARAGRAPH SEPARATOR
  )
}

impl<'i> Tokenizer<'i>
{
  /// Creates a new tokenizer with the given input.
  ///
  /// # Arguments
  ///
  /// * `input` - The input string to tokenize.
  ///
  /// # Returns
  ///
  /// A new tokenizer with the given input.
  pub fn new(input: &'i str) -> Self
  {
    Self {
      input: input.chars(),
      start: 0,
      len_remaining: input.len(),
    }
  }

  /// Get the amount of consumed input.
  ///
  /// # Returns
  ///
  /// The amount of consumed input.
  pub fn consumed_len(&self) -> usize
  {
    self.len_remaining - self.input.as_str().len()
  }

  /// Reset the consumed length counter to zero.
  pub fn reset_consumed_len(&mut self)
  {
    self.start += self.consumed_len();
    self.len_remaining = self.input.as_str().len();
  }

  /// Check if the input iterator has reached the end.
  ///
  /// # Returns
  ///
  /// `true` if the input iterator has reached the end, `false` otherwise.
  fn is_eof(&self) -> bool
  {
    self.input.as_str().is_empty()
  }

  /// Get the current character from the input iterator. And
  /// advance the iterator to the next character. This will return
  /// None if the iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The current character from the input iterator.
  fn advance(&mut self) -> Option<char>
  {
    self.input.next()
  }

  /// Peek the current character from the input iterator without
  /// advancing the iterator. This will return `EOF_CHAR` if the
  /// iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The current character from the input iterator.
  fn peek(&self) -> char
  {
    self.input.clone().next().unwrap_or(EOF_CHAR)
  }

  /// Peek the next character from the input iterator without
  /// advancing the iterator. This will return `EOF_CHAR` if the
  /// iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The next character from the input iterator.
  fn peek_next(&self) -> char
  {
    let mut peek = self.input.clone();
    peek.next();
    peek.next().unwrap_or(EOF_CHAR)
  }

  /// Parse a whitespace token.
  /// This will consume all the whitespace characters from the input.
  ///
  /// # Returns
  ///
  /// A whitespace token.
  fn parse_whitespace(&mut self) -> TokenKind
  {
    while is_whitespace(self.peek()) && !self.is_eof()
    {
      self.advance();
    }
    TokenKind::Whitespace
  }

  /// Parse an unknown token.
  /// This will consume the characters until it reaches (a whitespace or a
  /// syllable character).
  ///
  /// # Returns
  ///
  /// An unknown token.
  fn parse_unknown(&mut self) -> TokenKind
  {
    while !is_whitespace(self.peek())
      && !is_valid_mlcts_char(self.peek())
      && !self.is_eof()
    {
      self.advance();
    }
    TokenKind::Unknown
  }

  /// Parse a tone symbol if exists.
  ///
  /// # Returns
  ///
  /// A tone if valid, otherwise `None`.
  fn parse_tone(&mut self) -> Option<Tone>
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        Some(Tone::High)
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        Some(Tone::Creaky)
      }
      _ => None,
    }
  }

  /// Parse the vowel 'i' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_i(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return vowel!(I; High);
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return vowel!(I; Creaky);
      }
      't' =>
      {
        // consume 't'
        self.advance();
        // 'it' can't have a tone mark
        return vowel!(I, T);
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        // 'ip' can't have a tone mark
        return vowel!(I, P);
      }
      'n' =>
      {
        // consume 'n'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::I, Some(Virama::N), tone);
      }
      'm' =>
      {
        // consume 'm'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::I, Some(Virama::M), tone);
      }
      _ => vowel!(I),
    }
  }

  /// Parse the vowel 'ui' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_ui(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return vowel!(Ui; High);
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return vowel!(Ui; Creaky);
      }
      'k' =>
      {
        // consume 'k'
        self.advance();
        // 'uik' can't have a tone mark
        return vowel!(Ui, K);
      }
      c if c == 'n' && self.peek_next() == 'g' =>
      {
        // consume 'n' and 'g'
        self.advance();
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::Ui, Some(Virama::Ng), tone);
      }
      _ => vowel!(Ui),
    }
  }

  /// Parse the vowel 'u' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_u(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return vowel!(U; High);
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return vowel!(U; Creaky);
      }
      'i' =>
      {
        // consume 'i'
        self.advance();
        return self.parse_vowel_ui();
      }
      't' =>
      {
        // consume 't'
        self.advance();
        // 'ut' can't have a tone mark
        return vowel!(U, T);
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        // 'up' can't have a tone mark
        return vowel!(U, P);
      }
      'n' =>
      {
        // consume 'n'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::U, Some(Virama::N), tone);
      }
      'm' =>
      {
        // consume 'm'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::U, Some(Virama::M), tone);
      }
      _ => vowel!(U),
    }
  }

  /// Parse the vowel 'e' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_e(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return vowel!(E; High);
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return vowel!(E; Creaky);
      }
      _ => vowel!(E),
    }
  }

  /// Parse the vowel 'au' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_au(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return vowel!(Au; High);
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return vowel!(Au; Creaky);
      }
      'k' =>
      {
        // consume 'k'
        self.advance();
        // 'auk' can't have a tone mark
        return vowel!(Au, K);
      }
      c if c == 'n' && self.peek_next() == 'g' =>
      {
        // consume 'n' and 'g'
        self.advance();
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::Au, Some(Virama::Ng), tone);
      }
      _ => vowel!(Au),
    }
  }

  /// Parse the vowel 'an' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_an(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return Vowel::new(BasicVowel::A, Some(Virama::N), Some(Tone::High));
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return Vowel::new(BasicVowel::A, Some(Virama::N), Some(Tone::Creaky));
      }
      'g' =>
      {
        // consume 'g'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::A, Some(Virama::Ng), tone);
      }
      'y' =>
      {
        // consume 'y'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::A, Some(Virama::Ny), tone);
      }
      _ => vowel!(A, N),
    }
  }

  /// Parse the vowel 'a' and following tone, virama to get the vowel part.
  ///
  /// # Returns
  ///
  /// A valid vowel part.
  fn parse_vowel_a(&mut self) -> Vowel
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        return vowel!(A; High);
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        return vowel!(A; Creaky);
      }
      'k' =>
      {
        // consume 'k'
        self.advance();
        // 'ak' can't have a tone mark
        return vowel!(A, K);
      }
      'c' =>
      {
        // consume 'c'
        self.advance();
        // 'ac' can't have a tone mark
        return vowel!(A, C);
      }
      't' =>
      {
        // consume 't'
        self.advance();
        // 'at' can't have a tone mark
        return vowel!(A, T);
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        // 'ap' can't have a tone mark
        return vowel!(A, P);
      }
      'm' =>
      {
        // consume 'm'
        self.advance();
        let tone = self.parse_tone();
        return Vowel::new(BasicVowel::A, Some(Virama::M), tone);
      }
      'u' =>
      {
        // consume 'u'
        self.advance();
        return self.parse_vowel_au();
      }
      'n' =>
      {
        // consume 'n'
        self.advance();
        return self.parse_vowel_an();
      }
      _ => vowel!(A),
    }
  }

  /// Parse vowel to get the syllable token.
  ///
  /// # Arguments
  ///
  /// * `first_char` - The first vowel character.
  ///
  /// # Returns
  ///
  /// A syllable token if valid, otherwise an unknown token.
  fn parse_vowel(&mut self, first_char: char) -> TokenKind
  {
    TokenKind::Syllable(syllable!(match first_char
    {
      'i' => self.parse_vowel_i(),
      'u' => self.parse_vowel_u(),
      'e' => self.parse_vowel_e(),
      _ => unreachable!(),
    }))
  }

  /// Handle the special case of 'h' which can form a medial consonant.
  ///
  /// # Returns
  ///
  /// A valid consonant part.
  fn parse_consonant_h(&mut self) -> Consonant
  {
    match self.peek()
    {
      'k' =>
      {
        // consume 'k'
        self.advance();
        consonant!(Hk)
      }
      'c' =>
      {
        // consume 'c'
        self.advance();
        consonant!(Hc)
      }
      't' =>
      {
        // consume 't'
        self.advance();
        consonant!(Ht)
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        consonant!(Hp)
      }
      'n' => match self.peek_next()
      {
        'g' =>
        {
          // consume 'n'
          self.advance();
          // consume 'g'
          self.advance();
          consonant!(Ng, H)
        }
        'y' =>
        {
          // consume 'n'
          self.advance();
          // consume 'y'
          self.advance();
          consonant!(Ny, H)
        }
        _ =>
        {
          // consume 'n'
          self.advance();
          consonant!(N, H)
        }
      },
      'm' =>
      {
        // consume 'm'
        self.advance();
        consonant!(M, H)
      }
      'y' =>
      {
        // consume 'y'
        self.advance();
        consonant!(Y, H)
      }
      'r' =>
      {
        // consume 'r'
        self.advance();
        consonant!(R, H)
      }
      'l' =>
      {
        // consume 'l'
        self.advance();
        consonant!(L, H)
      }
      'w' =>
      {
        // consume 'w'
        self.advance();
        consonant!(W, H)
      }
      's' =>
      {
        // consume 's'
        self.advance();
        consonant!(S, H)
      }
      _ => consonant!(H),
    }
  }

  /// Parse the consonant and following vowel to get the syllable token.
  ///
  /// # Arguments
  ///
  /// * `first_char` - The first consonant character.
  ///
  /// # Returns
  ///
  /// A syllable token if valid, otherwise an unknown token.
  fn parse_consonant(&mut self, first_char: char) -> TokenKind
  {
    let consonant = match first_char
    {
      'k' => consonant!(K),
      'h' => self.parse_consonant_h(),
      'g' => match self.peek()
      {
        'h' =>
        {
          // consume 'y'
          self.advance();
          consonant!(Gh)
        }
        _ => consonant!(G),
      },
      'n' => match self.peek()
      {
        'g' =>
        {
          // consume 'g'
          self.advance();
          consonant!(Ng)
        }
        'y' =>
        {
          // consume 'y'
          self.advance();
          consonant!(Ny)
        }
        _ => consonant!(N),
      },
      'c' => consonant!(C),
      'j' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          consonant!(Jh)
        }
        _ => consonant!(J),
      },
      't' => consonant!(T),
      'd' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          consonant!(Dh)
        }
        _ => consonant!(D),
      },
      'p' => consonant!(P),
      'b' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          consonant!(Bh)
        }
        _ => consonant!(B),
      },
      'm' => consonant!(M),
      'y' => consonant!(Y),
      'r' => consonant!(R),
      'l' => consonant!(L),
      'w' => consonant!(W),
      's' => consonant!(S),
      'a' => consonant!(A),
      _ => unreachable!(),
    };

    // if basic consonant is 'a', then it's a vowel.
    // no need to check for medial consonant and vowel.
    if consonant.basic == BasicConsonant::A
    {
      let vowel = self.parse_vowel_a();
      return TokenKind::Syllable(syllable!(vowel));
    }

    // check for medial consonant 'y' and 'r'
    let consonant = if matches!(
      consonant.basic,
      BasicConsonant::K
        | BasicConsonant::Hk
        | BasicConsonant::G
        | BasicConsonant::Gh
        | BasicConsonant::Ng
        | BasicConsonant::T
        | BasicConsonant::P
        | BasicConsonant::Hp
        | BasicConsonant::B
        | BasicConsonant::M
        | BasicConsonant::Y
        | BasicConsonant::L
        | BasicConsonant::S
    ) && self.peek() == 'y'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::Y),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'y'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else if matches!(
      consonant.basic,
      BasicConsonant::K
        | BasicConsonant::Hk
        | BasicConsonant::G
        | BasicConsonant::Gh
        | BasicConsonant::Ng
        | BasicConsonant::T
        | BasicConsonant::D
        | BasicConsonant::P
        | BasicConsonant::Hp
        | BasicConsonant::B
        | BasicConsonant::M
    ) && self.peek() == 'r'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::R),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'r'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else
    {
      consonant
    };

    // since 'w' can be combined with almost all consonants, check for 'w'
    let consonant = if self.peek() == 'w'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::W),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'w'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else
    {
      consonant
    };

    let vowel = match self.peek()
    {
      'a' =>
      {
        // consume 'a'
        self.advance();
        Some(self.parse_vowel_a())
      }
      'i' =>
      {
        // consume 'i'
        self.advance();
        Some(self.parse_vowel_i())
      }
      'u' =>
      {
        // consume 'u'
        self.advance();
        Some(self.parse_vowel_u())
      }
      'e' =>
      {
        // consume 'e'
        self.advance();
        Some(self.parse_vowel_e())
      }
      _ => None,
    };

    if vowel.is_none()
    {
      // since there is no vowel, it's an unknown token.
      return TokenKind::Unknown;
    }

    TokenKind::Syllable(syllable!(consonant, vowel.unwrap()))
  }

  /// Get the next possible token from the input.
  /// This will return the next token from the input. If the input
  /// has reached the end, this will return an EOI token.
  ///
  /// # Returns
  ///
  /// The next token from the input.
  pub fn next_token(&mut self) -> Token
  {
    let first_char = match self.advance()
    {
      Some(c) => c,
      None => return Token::new(TokenKind::EndOfInput, 0, 0),
    };

    let token_kind = match first_char
    {
      'k' | 'h' | 'g' | 'n' | 'c' | 'j' | 't' | 'd' | 'p' | 'b' | 'm' | 'y'
      | 'r' | 'l' | 'w' | 's' | 'a' => self.parse_consonant(first_char),
      'i' | 'u' | 'e' => self.parse_vowel(first_char),
      c if is_whitespace(c) => self.parse_whitespace(),
      _ => self.parse_unknown(),
    };

    let token = Token::new(token_kind, self.start, self.consumed_len());
    self.reset_consumed_len();
    token
  }
}
