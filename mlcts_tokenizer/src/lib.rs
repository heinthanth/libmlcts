use std::str::Chars;

// re-export mlcts_core crate
pub use mlcts_core;
use mlcts_core::*;

pub const EOF_CHAR: char = '\0';

/// Represents the kind of a token generated by the tokenizer.
/// Token kind can be a syllable or other types of tokens.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TokenKind
{
  /// An unknown token.
  Unknown,
  /// A whitespace token.
  Whitespace,
  /// A syllable token.
  Syllable(Syllable),
  /// An EOI token.
  EndOfInput,
}

/// Represents a token generated by the tokenizer.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Token
{
  /// The kind of the token.
  pub kind: TokenKind,
  /// The start position of the token in the input.
  pub start: usize,
  /// The length of the token in the input.
  pub len: usize,
}

impl Token
{
  /// Creates a new token with the given kind, start position, and length.
  ///
  /// # Arguments
  ///
  /// * `kind` - The kind of the token.
  /// * `start` - The start position of the token in the input.
  /// * `len` - The length of the token in the input.
  ///
  /// # Returns
  ///
  /// A new token with the given kind, start position, and length.
  pub fn new(kind: TokenKind, start: usize, len: usize) -> Self
  {
    Self { kind, start, len }
  }
}

/// Creates an iterator that produces tokens from the input string.
///
/// # Arguments
///
/// * `input` - The input string to tokenize.
///
/// # Returns
///
/// An iterator that produces tokens from the input string.
pub fn tokenize(input: &str) -> impl Iterator<Item = Token> + '_
{
  let mut cursor = Tokenizer::new(input);
  std::iter::from_fn(move || {
    let token = cursor.next_token();
    if token.kind != TokenKind::EndOfInput
    {
      Some(token)
    }
    else
    {
      None
    }
  })
}

/// The tokenizer for MLCTS.
/// This will convert the string written in MLCTS to a sequence of syllables or
/// other tokens.
#[derive(Debug, Clone)]
pub struct Tokenizer<'i>
{
  /// The input iterator.
  input: Chars<'i>,
  /// The start position of the input.
  start: usize,
  /// Length remaining in the input.
  len_remaining: usize,
}

/// Check if a character is a valid character used in MLCTS.
/// This can be used to check the boundary or range of text which needs to be
/// further analyzed to see if it is a valid syllable.
///
/// # Arguments
///
/// * `c` - The character to check.
///
/// # Returns
///
/// `true` if the character is a valid character used in MLCTS, `false`
/// otherwise.
fn is_valid_mlcts_char(c: char) -> bool
{
  matches!(
    c,
    'k'
      | 'h'
      | 'g'
      | 'n'
      | 'c'
      | 'j'
      | 't'
      | 'd'
      | 'p'
      | 'b'
      | 'm'
      | 'y'
      | 'r'
      | 'l'
      | 'w'
      | 's'
      | 'a'
      | 'i'
      | 'u'
      | 'e'
      | '.'
      | ':'
  )
}

/// Check if the current character is a whitespace character.
///
/// # Returns
///
/// `true` if the current character is a whitespace character, `false`
/// otherwise.
fn is_whitespace(c: char) -> bool
{
  matches!(
    c,
    // Usual ASCII suspects
    '\u{0009}'   // \t
    | '\u{000A}' // \n
    | '\u{000B}' // vertical tab
    | '\u{000C}' // form feed
    | '\u{000D}' // \r
    | '\u{0020}' // space
    // NEXT LINE from latin1
    | '\u{0085}'
    // Bidi markers
    | '\u{200E}' // LEFT-TO-RIGHT MARK
    | '\u{200F}' // RIGHT-TO-LEFT MARK
    // Dedicated whitespace characters from Unicode
    | '\u{2028}' // LINE SEPARATOR
    | '\u{2029}' // PARAGRAPH SEPARATOR
  )
}

impl<'i> Tokenizer<'i>
{
  /// Creates a new tokenizer with the given input.
  ///
  /// # Arguments
  ///
  /// * `input` - The input string to tokenize.
  ///
  /// # Returns
  ///
  /// A new tokenizer with the given input.
  pub fn new(input: &'i str) -> Self
  {
    Self {
      input: input.chars(),
      start: 0,
      len_remaining: input.len(),
    }
  }

  /// Get the amount of consumed input.
  ///
  /// # Returns
  ///
  /// The amount of consumed input.
  pub fn consumed_len(&self) -> usize
  {
    self.len_remaining - self.input.as_str().len()
  }

  /// Reset the consumed length counter to zero.
  pub fn reset_consumed_len(&mut self)
  {
    self.start += self.consumed_len();
    self.len_remaining = self.input.as_str().len();
  }

  /// Check if the input iterator has reached the end.
  ///
  /// # Returns
  ///
  /// `true` if the input iterator has reached the end, `false` otherwise.
  fn is_eof(&self) -> bool
  {
    self.input.as_str().is_empty()
  }

  /// Get the current character from the input iterator. And
  /// advance the iterator to the next character. This will return
  /// None if the iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The current character from the input iterator.
  fn advance(&mut self) -> Option<char>
  {
    self.input.next().map(|c| c.to_ascii_lowercase())
  }

  /// Consumes n characters from the input iterator.
  ///
  /// # Arguments
  ///
  /// * `n` - The number of characters to consume.
  fn advance_n(&mut self, n: usize)
  {
    for _ in 0 .. n
    {
      self.advance();
    }
  }

  /// Peek the current character from the input iterator without
  /// advancing the iterator. This will return `EOF_CHAR` if the
  /// iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The current character from the input iterator.
  fn peek(&self) -> char
  {
    self
      .input
      .clone()
      .next()
      .map(|c| c.to_ascii_lowercase())
      .unwrap_or(EOF_CHAR)
  }

  /// Peek the nth character from the input iterator without
  /// advancing the iterator. This will return `EOF_CHAR` if the
  /// iterator has reached the end of the input.
  ///
  /// # Arguments
  ///
  /// * `n` - The number of characters to peek.
  ///
  /// # Returns
  ///
  /// The nth character from the input iterator.
  fn peek_nth(&self, n: usize) -> char
  {
    let mut peek = self.input.clone();
    for _ in 0 .. n
    {
      peek.next();
    }
    peek
      .next()
      .map(|c| c.to_ascii_lowercase())
      .unwrap_or(EOF_CHAR)
  }

  /// Peek the next character from the input iterator without
  /// advancing the iterator. This will return `EOF_CHAR` if the
  /// iterator has reached the end of the input.
  ///
  /// # Returns
  ///
  /// The next character from the input iterator.
  fn peek_next(&self) -> char
  {
    let mut peek = self.input.clone();
    peek.next();
    peek
      .next()
      .map(|c| c.to_ascii_lowercase())
      .unwrap_or(EOF_CHAR)
  }

  /// Parse a whitespace token.
  /// This will consume all the whitespace characters from the input.
  ///
  /// # Returns
  ///
  /// A whitespace token.
  fn parse_whitespace(&mut self) -> TokenKind
  {
    while is_whitespace(self.peek()) && !self.is_eof()
    {
      self.advance();
    }
    TokenKind::Whitespace
  }

  /// Parse an unknown token.
  /// This will consume the characters until it reaches (a whitespace or a
  /// syllable character).
  ///
  /// # Returns
  ///
  /// An unknown token.
  fn parse_unknown(&mut self) -> TokenKind
  {
    while !is_whitespace(self.peek())
      && !is_valid_mlcts_char(self.peek())
      && !self.is_eof()
    {
      self.advance();
    }
    TokenKind::Unknown
  }

  /// Parse a tone symbol if exists.
  ///
  /// # Returns
  ///
  /// A tone if valid, otherwise `None`.
  fn parse_tone(&mut self) -> Option<Tone>
  {
    match self.peek()
    {
      ':' =>
      {
        // consume ':'
        self.advance();
        Some(Tone::High)
      }
      '.' =>
      {
        // consume '.'
        self.advance();
        Some(Tone::Creaky)
      }
      _ => None,
    }
  }

  /// Select vowel from possible candidates.
  ///
  /// # Arguments
  ///
  /// * `syllables` - The possible syllables.
  ///
  /// # Returns
  ///
  /// The selected syllable.
  fn select_vowel(&self, syllables: Vec<(Syllable, Syllable)>) -> Syllable
  {
    // this will always return the first syllable.
    // we need to implement dictionary checkings to select the correct syllable.
    return syllables[0].0.clone();
  }

  /// In certain cases like "lapa", tokenization can be ambiguous.
  /// And it should output "la" and "pa" as separate tokens instead of "lap" and
  /// "a". But this only applies to the case that there's a vowel after the
  /// virama consonant and virama won't be used in a stacked consonant.
  ///
  /// # Arguments
  ///
  /// * `original_vowel` - The original vowel.
  /// * `possible_virama` - The possible virama consonant.
  /// * `virama_len` - The length of the virama consonant to eat.
  /// * `has_tone` - Whether the vowel has a tone.
  ///
  /// # Returns
  ///
  /// A vowel token.
  fn handle_possible_ambiguity(
    &mut self,
    original_vowel: BasicVowel,
    possible_virama: Virama,
    virama_len: usize,
    has_tone: bool,
    consonant_part: Consonant,
  ) -> Vowel
  {
    let next_char_followed_virama = self.peek_nth(virama_len);

    if !matches!(next_char_followed_virama, 'a' | 'i' | 'u' | 'e')
    {
      // if there's no vowel after the virama consonant, we don't need to check
      // for possible ambiguity.
      self.advance_n(virama_len);
      let tone = if has_tone { self.parse_tone() } else { None };
      return Vowel::new(original_vowel, Some(possible_virama), tone);
    }

    // we will try to generate the following combinations:
    // 1. (current consonant + current vowel + virama) + (next vowel)
    // 2. (current consonant + current vowel) + (virama + next consonant + next vowel)
    // and select the best one.
    let current_input_str = self.input.as_str();

    // remove the virama consonant and the vowel after it.
    let mut cloned_tokenizer = Tokenizer::new(current_input_str);
    cloned_tokenizer.advance_n(virama_len + 1);
    let candidate_vowel = cloned_tokenizer.parse_vowel(
      next_char_followed_virama,
      Consonant::simple(possible_virama.into()),
    );
    let candidate_syllable =
      syllable!(Consonant::simple(possible_virama.into()), candidate_vowel);

    let base_syllable = syllable!(
      consonant_part,
      Vowel::new(original_vowel, Some(possible_virama), None)
    );
    // assume that we consume the virama consonant.
    let mut cloned_tokenizer_3 = Tokenizer::new(current_input_str);
    cloned_tokenizer_3.advance_n(virama_len);
    let following_syllable_2_vowel =
      cloned_tokenizer_3.parse_vowel(next_char_followed_virama, consonant!(A));
    let following_syllable_2 =
      syllable!(consonant!(A), following_syllable_2_vowel);

    let selected_syllable = self.select_vowel(vec![
      (base_syllable.clone(), following_syllable_2),
      (
        syllable!(consonant_part, Vowel::simple(original_vowel)),
        candidate_syllable,
      ),
    ]);

    if selected_syllable == base_syllable
    {
      // if the selected syllable is the base syllable, then we need to
      // consume the virama consonant.
      self.advance_n(virama_len);
      return Vowel::new(original_vowel, Some(possible_virama), None);
    }

    // if the selected syllable is the candidate 1, then we don't need to
    // consume the virama consonant since this will be part of the next
    // iteration.
    Vowel::new(original_vowel, None, None)
  }

  /// Parse virama, stacked consonants and tone if exists.
  ///
  /// # Returns
  ///
  /// a vowel part.
  fn parse_virama_and_tone(
    &mut self,
    original_vowel: BasicVowel,
    consonant_part: Consonant,
  ) -> Vowel
  {
    match (
      self.peek(),
      self.peek_next(),
      self.peek_nth(2),
      self.peek_nth(3),
    )
    {
      ('.', ..) =>
      {
        // consume '.'
        self.advance();
        return Vowel::new(original_vowel, None, Some(Tone::Creaky));
      }
      (':', ..) =>
      {
        // consume ':'
        self.advance();
        return Vowel::new(original_vowel, None, Some(Tone::High));
      }
      ('k', ..) => self.handle_possible_ambiguity(
        original_vowel,
        Virama::K,
        1,
        false,
        consonant_part,
      ),
      ('g', 'g', 'h', ..) | ('g', 'g', ..) =>
      {
        // consume 'g'
        self.advance();
        // 'ag' might be a stacked consonant
        return Vowel::new(original_vowel, Some(Virama::G), None);
      }
      ('c', ..) => self.handle_possible_ambiguity(
        original_vowel,
        Virama::C,
        1,
        false,
        consonant_part,
      ),
      ('j', 'j', 'h', ..) | ('j', 'j', ..) =>
      {
        // consume 'j'
        self.advance();
        // 'aj' might be a stacked consonant
        return Vowel::new(original_vowel, Some(Virama::J), None);
      }
      ('t', ..) => self.handle_possible_ambiguity(
        original_vowel,
        Virama::T,
        1,
        false,
        consonant_part,
      ),
      ('h', 't', 'h', 't') =>
      {
        // consume 'h'
        self.advance();
        // consume 't'
        self.advance();
        // 'aht' might be a stacked consonant
        return Vowel::new(original_vowel, Some(Virama::Ht), None);
      }
      ('d', 'd', 'h', ..) | ('d', 'd', ..) =>
      {
        // consume 'd'
        self.advance();
        // 'ad' might be a stacked consonant
        return Vowel::new(original_vowel, Some(Virama::D), None);
      }
      ('p', ..) => self.handle_possible_ambiguity(
        original_vowel,
        Virama::P,
        1,
        false,
        consonant_part,
      ),
      ('b', 'b', 'h', ..) | ('b', 'b', ..) =>
      {
        // consume 'b'
        self.advance();
        return Vowel::new(original_vowel, Some(Virama::B), None);
      }
      ('m', ..) => self.handle_possible_ambiguity(
        original_vowel,
        Virama::M,
        1,
        true,
        consonant_part,
      ),
      ('n', '.', ..) =>
      {
        // consume 'n'
        self.advance();
        // consume '.'
        self.advance();
        return Vowel::new(original_vowel, Some(Virama::N), Some(Tone::Creaky));
      }
      ('n', ':', ..) =>
      {
        // consume 'n'
        self.advance();
        // consume ':'
        self.advance();
        return Vowel::new(original_vowel, Some(Virama::N), Some(Tone::High));
      }
      ('n', 'g', ..) => self.handle_possible_ambiguity(
        original_vowel,
        Virama::Ng,
        2,
        true,
        consonant_part,
      ),
      ('n', 'y', ..) => self.handle_possible_ambiguity(
        original_vowel,
        Virama::Ny,
        2,
        true,
        consonant_part,
      ),
      ('n', ..) => self.handle_possible_ambiguity(
        original_vowel,
        Virama::N,
        1,
        true,
        consonant_part,
      ),
      ('s', 's', ..) =>
      {
        // consume 's'
        self.advance();
        return Vowel::new(original_vowel, Some(Virama::S), None);
      }
      ('l', 'l', ..) =>
      {
        // consume 'l'
        self.advance();
        return Vowel::new(original_vowel, Some(Virama::L), None);
      }
      _ => Vowel::simple(original_vowel),
    }
  }

  /// Parse vowel based on the first character.
  ///
  /// # Arguments
  ///
  /// * `first_char` - The first vowel character.
  /// * `consonant_part` - The consonant part of the syllable.
  ///
  /// # Returns
  ///
  /// A vowel token if valid, otherwise an unknown token.
  fn parse_vowel(
    &mut self,
    first_char: char,
    consonant_part: Consonant,
  ) -> Vowel
  {
    match (first_char, self.peek())
    {
      ('a', 'u') =>
      {
        // consume 'u'
        self.advance();
        self.parse_virama_and_tone(BasicVowel::Au, consonant_part)
      }
      ('a', _) => self.parse_virama_and_tone(BasicVowel::A, consonant_part),
      ('i', _) => self.parse_virama_and_tone(BasicVowel::I, consonant_part),
      ('u', 'i') =>
      {
        // consume 'i'
        self.advance();
        self.parse_virama_and_tone(BasicVowel::Ui, consonant_part)
      }
      ('u', _) => self.parse_virama_and_tone(BasicVowel::U, consonant_part),
      ('e', _) => self.parse_virama_and_tone(BasicVowel::E, consonant_part),
      _ => unreachable!(),
    }
  }

  /// Parse vowel syllable
  ///
  /// # Arguments
  ///
  /// * `first_char` - The first vowel character.
  ///
  /// # Returns
  ///
  /// A syllable token if valid, otherwise an unknown token.
  fn parse_vowel_syllable(&mut self, first_char: char) -> TokenKind
  {
    TokenKind::Syllable(syllable!(self.parse_vowel(first_char, consonant!(A))))
  }

  /// Handle the special case of 'h' which can form a medial consonant.
  ///
  /// # Returns
  ///
  /// A valid consonant part.
  fn parse_consonant_h(&mut self) -> Consonant
  {
    match self.peek()
    {
      'k' =>
      {
        // consume 'k'
        self.advance();
        consonant!(Hk)
      }
      'c' =>
      {
        // consume 'c'
        self.advance();
        consonant!(Hc)
      }
      't' =>
      {
        // consume 't'
        self.advance();
        consonant!(Ht)
      }
      'p' =>
      {
        // consume 'p'
        self.advance();
        consonant!(Hp)
      }
      'n' => match self.peek_next()
      {
        'g' =>
        {
          // consume 'n'
          self.advance();
          // consume 'g'
          self.advance();
          consonant!(Ng, H)
        }
        'y' =>
        {
          // consume 'n'
          self.advance();
          // consume 'y'
          self.advance();
          consonant!(Ny, H)
        }
        _ =>
        {
          // consume 'n'
          self.advance();
          consonant!(N, H)
        }
      },
      'm' =>
      {
        // consume 'm'
        self.advance();
        consonant!(M, H)
      }
      'y' =>
      {
        // consume 'y'
        self.advance();
        consonant!(Y, H)
      }
      'r' =>
      {
        // consume 'r'
        self.advance();
        consonant!(R, H)
      }
      'l' =>
      {
        // consume 'l'
        self.advance();
        consonant!(L, H)
      }
      'w' =>
      {
        // consume 'w'
        self.advance();
        consonant!(W, H)
      }
      's' =>
      {
        // consume 's'
        self.advance();
        consonant!(S, H)
      }
      _ => consonant!(H),
    }
  }

  /// Parse the consonant and following vowel to get the syllable token.
  ///
  /// # Arguments
  ///
  /// * `first_char` - The first consonant character.
  ///
  /// # Returns
  ///
  /// A syllable token if valid, otherwise an unknown token.
  fn parse_consonant(&mut self, first_char: char) -> TokenKind
  {
    let consonant = match first_char
    {
      'k' => consonant!(K),
      'h' => self.parse_consonant_h(),
      'g' => match self.peek()
      {
        'h' =>
        {
          // consume 'y'
          self.advance();
          consonant!(Gh)
        }
        _ => consonant!(G),
      },
      'n' => match self.peek()
      {
        'g' =>
        {
          // consume 'g'
          self.advance();
          consonant!(Ng)
        }
        'y' =>
        {
          // consume 'y'
          self.advance();
          consonant!(Ny)
        }
        _ => consonant!(N),
      },
      'c' => consonant!(C),
      'j' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          consonant!(Jh)
        }
        _ => consonant!(J),
      },
      't' => consonant!(T),
      'd' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          consonant!(Dh)
        }
        _ => consonant!(D),
      },
      'p' => consonant!(P),
      'b' => match self.peek()
      {
        'h' =>
        {
          // consume 'h'
          self.advance();
          consonant!(Bh)
        }
        _ => consonant!(B),
      },
      'm' => consonant!(M),
      'y' => consonant!(Y),
      'r' => consonant!(R),
      'l' => consonant!(L),
      'w' => consonant!(W),
      's' => consonant!(S),
      'a' => consonant!(A),
      _ => unreachable!(),
    };

    // if basic consonant is 'a', then it's a vowel.
    // no need to check for medial consonant and vowel.
    if consonant.basic == BasicConsonant::A
    {
      let vowel = self.parse_vowel('a', consonant);
      return TokenKind::Syllable(syllable!(vowel));
    }

    // check for medial consonant 'y' and 'r'
    let consonant = if matches!(
      consonant.basic,
      BasicConsonant::K
        | BasicConsonant::Hk
        | BasicConsonant::G
        | BasicConsonant::Gh
        | BasicConsonant::Ng
        | BasicConsonant::T
        | BasicConsonant::P
        | BasicConsonant::Hp
        | BasicConsonant::B
        | BasicConsonant::M
        | BasicConsonant::Y
        | BasicConsonant::L
        | BasicConsonant::S
    ) && self.peek() == 'y'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::Y),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'y'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else if matches!(
      consonant.basic,
      BasicConsonant::K
        | BasicConsonant::Hk
        | BasicConsonant::G
        | BasicConsonant::Gh
        | BasicConsonant::Ng
        | BasicConsonant::T
        | BasicConsonant::D
        | BasicConsonant::P
        | BasicConsonant::Hp
        | BasicConsonant::B
        | BasicConsonant::M
    ) && self.peek() == 'r'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::R),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'r'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else
    {
      consonant
    };

    // since 'w' can be combined with almost all consonants, check for 'w'
    let consonant = if self.peek() == 'w'
    {
      let combined_medial = MedialDiacritic::combine_medial_diacritics(
        consonant.medial,
        Some(MedialDiacritic::W),
      );
      if let Ok(Some(medial)) = combined_medial
      {
        // consume 'w'
        self.advance();
        Consonant::with_medial(consonant.basic, medial)
      }
      else
      {
        consonant
      }
    }
    else
    {
      consonant
    };

    let vowel = if matches!(self.peek(), 'a' | 'i' | 'u' | 'e')
    {
      let curr = self.advance().unwrap();
      Some(self.parse_vowel(curr, consonant))
    }
    else
    {
      None
    };

    if vowel.is_none()
    {
      // since there is no vowel, it's an unknown token.
      return TokenKind::Unknown;
    }

    TokenKind::Syllable(syllable!(consonant, vowel.unwrap()))
  }

  /// Get the next possible token from the input.
  /// This will return the next token from the input. If the input
  /// has reached the end, this will return an EOI token.
  ///
  /// # Returns
  ///
  /// The next token from the input.
  pub fn next_token(&mut self) -> Token
  {
    let first_char = match self.advance()
    {
      Some(c) => c,
      None => return Token::new(TokenKind::EndOfInput, 0, 0),
    };

    let token_kind = match first_char
    {
      'k' | 'h' | 'g' | 'n' | 'c' | 'j' | 't' | 'd' | 'p' | 'b' | 'm' | 'y'
      | 'r' | 'l' | 'w' | 's' | 'a' => self.parse_consonant(first_char),
      'i' | 'u' | 'e' => self.parse_vowel_syllable(first_char),
      c if is_whitespace(c) => self.parse_whitespace(),
      _ => self.parse_unknown(),
    };

    let token = Token::new(token_kind, self.start, self.consumed_len());
    self.reset_consumed_len();
    token
  }
}

#[cfg(test)]
mod tests
{
  use super::*;

  #[test]
  fn tokenizer_development_test()
  {
    let mut tokenizer = Tokenizer::new("lapa");
    println!("{:?}", tokenizer.next_token());
    println!("{:?}", tokenizer.next_token());
  }
}
