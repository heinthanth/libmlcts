use std::path::Path;

use csv::StringRecord;
use proc_macro2::TokenStream;
use quote::quote;
use rand::seq::IteratorRandom;
use syn::Ident;

fn main()
{
  let single_syllable_tests = gen_single_syllable_tests();

  let mod_code = quote! {
    //! @generated
    //!
    //! This is generated by `mlcts_dev_tools/src/gen_tokenizer_tests.rs`.
    //! Do not modify this file directly.

    #[cfg(test)]
    mod tokenizer_tests
    {
      use mlcts_tokenizer::*;

      #(#single_syllable_tests)*
    }
  }
  .to_string();

  let syntax_tree = syn::parse_file(mod_code.as_str()).unwrap();
  let formatted = prettyplease::unparse(&syntax_tree);

  let test_file_path = Path::new(env!("CARGO_MANIFEST_DIR"))
    .join("..")
    .join("mlcts_tokenizer")
    .join("tests")
    .join("tests.rs");
  std::fs::write(test_file_path, formatted).unwrap();
}

/// Generate single syllable test cases
///
/// # Returns
///
/// Rust code for the test cases
fn gen_single_syllable_tests() -> Vec<TokenStream>
{
  read_csv_rows("tests/inputs_single_syllable.csv")
    .into_iter()
    .map(gen_single_syllable_test)
    .collect::<Vec<TokenStream>>()
}

/// Generate a random string of a given length
///
/// # Arguments
///
/// * `length` - The length of the random string
///
/// # Returns
///
/// A random string of the given length
fn generate_random_string(length: usize) -> String
{
  let characters =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

  let mut rng = rand::thread_rng();
  (0 .. length)
    .map(|_| characters.chars().choose(&mut rng).unwrap())
    .collect()
}

/// Generate Rust code for single syllable test cases
///
/// # Arguments
///
/// * `row` - A row from the CSV file
///
/// # Returns
///
/// Rust code for the test case
fn gen_single_syllable_test(row: StringRecord) -> TokenStream
{
  let i = row.get(2).unwrap();
  let c = row.get(3).unwrap();
  let m = row.get(4).unwrap();
  let v = row.get(5).unwrap();
  let vi = row.get(6).unwrap();
  let t = row.get(7).unwrap();

  let f_ident = Ident::new(
    format!(
      "single_syllable_test_{}{}",
      i.replace(".", "_dot").replace(":", "_colon"),
      (format!("_{}", generate_random_string(8))).to_ascii_lowercase(),
      // ""
    )
    .as_str(),
    proc_macro2::Span::call_site(),
  );

  let c_ident = Ident::new(c, proc_macro2::Span::call_site());
  let v_ident = Ident::new(v, proc_macro2::Span::call_site());
  let m_expr = if m.is_empty()
  {
    quote! { None }
  }
  else
  {
    let m_ident = Ident::new(m, proc_macro2::Span::call_site());
    quote! { Some(mlcts_core::MedialDiacritic::#m_ident) }
  };
  let vi_expr = if vi.is_empty()
  {
    quote! { None }
  }
  else
  {
    let vi_ident = Ident::new(vi, proc_macro2::Span::call_site());
    quote! { Some(mlcts_core::Virama::#vi_ident) }
  };
  let t_expr = if t.is_empty()
  {
    quote! { None }
  }
  else
  {
    let t_ident = Ident::new(t, proc_macro2::Span::call_site());
    quote! { Some(mlcts_core::Tone::#t_ident) }
  };

  quote! {
    #[test]
    fn #f_ident() {
      let expected_consonant = mlcts_core::Consonant::new(mlcts_core::BasicConsonant::#c_ident, #m_expr);
      let expected_vowel = mlcts_core::Vowel::new(mlcts_core::BasicVowel::#v_ident, #vi_expr, #t_expr);
      let expected_syllable = mlcts_core::Syllable::new(expected_consonant, expected_vowel);

      let mut tokenizer = Tokenizer::new(#i);
      let next_token = tokenizer.next_token();
      assert_eq!(next_token.kind, TokenKind::Syllable(expected_syllable));
    }
  }
}

/// Helper function to read CSV rows from a file.
/// Path are relative to the workspace root crates
fn read_csv_rows(path: &str) -> Vec<StringRecord>
{
  let test_input_path = Path::new(env!("CARGO_MANIFEST_DIR"))
    .join("..")
    .join("mlcts_tokenizer")
    .join(path);

  let mut rdr = csv::Reader::from_path(test_input_path).unwrap();
  rdr.records().into_iter().map(|r| r.unwrap()).collect()
}
